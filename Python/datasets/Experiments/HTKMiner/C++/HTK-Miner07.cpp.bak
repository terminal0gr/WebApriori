#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <unordered_map>
#include <chrono>
#include <bit> // For std::popcount (C++20)

#ifdef _WIN32
#include <windows.h>
#include <psapi.h>
#else
#include <sys/resource.h>
#endif

size_t getPeakRSS() {
#ifdef _WIN32
    PROCESS_MEMORY_COUNTERS info;
    GetProcessMemoryInfo(GetCurrentProcess(), &info, sizeof(info));
    return (size_t)info.PeakWorkingSetSize;
#else
    struct rusage usage;
    getrusage(RUSAGE_SELF, &usage);
    return (size_t)(usage.ru_maxrss * 1024); // Convert KB to Bytes
#endif
}

// ==========================================
// 1. STRUCTURES & HEAP
// ==========================================

struct TopKFIM {
    std::vector<int> items; // Stores Rank IDs
    int support;
};

struct DynamicBitSet {
    std::vector<uint64_t> data;
    size_t num_bits;

    DynamicBitSet() : num_bits(0) {}
    void resize(size_t n_bits) {
        num_bits = n_bits;
        data.assign((n_bits + 63) / 64, 0);
    }
    void set(size_t index) {
        data[index / 64] |= (1ULL << (index % 64));
    }
    size_t count() const {
        size_t c = 0;
        for (uint64_t val : data) c += std::popcount(val);
        return c;
    }
    static DynamicBitSet intersect(const DynamicBitSet& a, const DynamicBitSet& b) {
        DynamicBitSet res;
        res.num_bits = a.num_bits;
        res.data.resize(a.data.size());
        for (size_t i = 0; i < a.data.size(); ++i) res.data[i] = a.data[i] & b.data[i];
        return res;
    }
    static DynamicBitSet diff(const DynamicBitSet& a, const DynamicBitSet& b) {
        DynamicBitSet res;
        res.num_bits = a.num_bits;
        res.data.resize(a.data.size());
        for (size_t i = 0; i < a.data.size(); ++i) res.data[i] = a.data[i] & (~b.data[i]);
        return res;
    }
};

struct Candidate {
    std::vector<int> itemset; // Using Rank IDs
    DynamicBitSet bits;
    int support;

    // Lexicographical sort on Ranks = Support Descending sort
    bool operator<(const Candidate& other) const {
        return itemset < other.itemset;
    }
};

class QuickHeap {
    int K;
    std::vector<int> heapList;
public:
    QuickHeap(int k) : K(k) { heapList.reserve(K + 1); }
    void initialFill(const std::vector<int>& supports) {
        heapList = supports;
        std::sort(heapList.begin(), heapList.end(), std::greater<int>());
        if (heapList.size() > K) heapList.resize(K);
    }
    int insert(int value) {
        if (heapList.size() >= K && value <= heapList.back()) return heapList.back();
        auto it = std::upper_bound(heapList.begin(), heapList.end(), value, std::greater<int>());
        heapList.insert(it, value);
        if (heapList.size() > K) heapList.pop_back();
        return (heapList.size() == K) ? heapList.back() : 0;
    }
    int getMinSup() const { return (heapList.size() < K) ? 0 : heapList.back(); }
};

// ==========================================
// 2. THE MINER CLASS
// ==========================================

class HTKMiner {
private:
    // Mappings (The 3-Tier System)
    std::unordered_map<std::string, int> itemToId; // Name -> RawID
    std::unordered_map<int, std::string> idToItem; // RawID -> Name
    std::vector<int> rankToRaw;                    // Rank -> RawID
    
    QuickHeap heap;
    int min_count = 0;
    int topK;
    int num_of_transactions = 0;
    bool tidSet; 
    std::vector<TopKFIM> finalTopK;

    using ItemStat = std::pair<int, int>; // {Support, RawID}

public:
    HTKMiner(int k, bool mode = true) : heap(k), topK(k), tidSet(mode) {}

    void mine(const std::string& filepath) {
        auto start = std::chrono::high_resolution_clock::now();

        // Step 1: Read and Rank
        std::vector<Candidate> currentLevel = readAndRank(filepath);
        
        int level = 1;
        while (!currentLevel.empty()) {
            std::vector<Candidate> nextLevel;
            int n = currentLevel.size();

            // ==========================================
            // SMART ITERATION MECHANISM (SIME)
            // ==========================================
            for (int j = 1; j < n; ++j) {
                // Pruning A: If the j-th itemset is below min_count, all subsequent itemsets are too
                if (currentLevel[j].support < min_count) break;

                for (int i = 0; i < j; ++i) {
                    // Pruning B: Since i < j and sorted by support, if i is below, j is definitely below
                    if (currentLevel[i].support < min_count) continue;

                    // Pruning C: Prefix Matching
                    bool match = true;
                    if (level > 1) {
                        for (int k = 0; k < level - 1; ++k) {
                            if (currentLevel[i].itemset[k] != currentLevel[j].itemset[k]) {
                                match = false; break;
                            }
                        }
                    }

                    if (match) {
                        DynamicBitSet newBits;
                        int newSup = 0;

                        if (tidSet || level == 1) {
                            newBits = DynamicBitSet::intersect(currentLevel[i].bits, currentLevel[j].bits);
                            newSup = newBits.count();
                        } else {
                            newBits = DynamicBitSet::diff(currentLevel[i].bits, currentLevel[j].bits);
                            newSup = currentLevel[i].support - newBits.count();
                        }

                        if (newSup >= min_count) {
                            min_count = heap.insert(newSup);

                            std::vector<int> newKey = currentLevel[i].itemset;
                            newKey.push_back(currentLevel[j].itemset.back());

                            finalTopK.push_back({newKey, newSup});
                            nextLevel.push_back({std::move(newKey), std::move(newBits), newSup});
                        }
                    }
                }
            }
            currentLevel = std::move(nextLevel);
            std::sort(currentLevel.begin(), currentLevel.end()); // Maintains Rank/Support Order
            level++;
        }

        cleanupResults();
        auto end = std::chrono::high_resolution_clock::now();
        std::cout << "Execution Time: " << std::chrono::duration<double>(end - start).count() << "s\n";
    }

    void saveResults(const std::string& path) {
        std::ofstream out(path);
        for (const auto& res : finalTopK) {
            for (size_t i = 0; i < res.items.size(); ++i) {
                out << idToItem[rankToRaw[res.items[i]]] << (i == res.items.size()-1 ? "" : " ");
            }
            out << " #SUP: " << res.support << "\n";
        }
    }

private:
    std::vector<Candidate> readAndRank(const std::string& path) {
        std::ifstream file(path);
        std::string line;
        std::unordered_map<int, std::vector<int>> vR; 
        int transIdx = 0, rawIdx = 0;

        while (std::getline(file, line)) {
            std::stringstream ss(line);
            std::string item;
            while (ss >> item) {
                if (itemToId.find(item) == itemToId.end()) {
                    itemToId[item] = rawIdx;
                    idToItem[rawIdx] = item;
                    rawIdx++;
                }
                int id = itemToId[item];
                if (vR[id].empty() || vR[id].back() != transIdx) vR[id].push_back(transIdx);
            }
            transIdx++;
        }
        num_of_transactions = transIdx;

        // Rank items by support
        std::vector<ItemStat> stats;
        for (auto& [id, tids] : vR) stats.push_back({(int)tids.size(), id});
        
        std::sort(stats.begin(), stats.end(), [](const ItemStat& a, const ItemStat& b) {
            return a.first > b.first; 
        });

        // Determine Initial min_count and Cutoff
        int mS = (stats.size() >= topK) ? stats[topK-1].first : 0;
        this->min_count = mS;

        std::vector<int> heapInit;
        std::vector<Candidate> l1;
        for (size_t rank = 0; rank < stats.size(); ++rank) {
            if (stats[rank].first < min_count) break;
            
            int rawID = stats[rank].second;
            int sup = stats[rank].first;

            rankToRaw.push_back(rawID);
            heapInit.push_back(sup);

            DynamicBitSet bs;
            bs.resize(num_of_transactions);
            for (int t : vR[rawID]) bs.set(t);

            finalTopK.push_back({{(int)rank}, sup});
            l1.push_back({{(int)rank}, std::move(bs), sup});
        }
        heap.initialFill(heapInit);
        std::sort(l1.begin(), l1.end());
        return l1;
    }

    void cleanupResults() {
        finalTopK.erase(std::remove_if(finalTopK.begin(), finalTopK.end(),
            [this](const TopKFIM& f) { return f.support < min_count; }), finalTopK.end());
    }
};

int main(int argc, char** argv) {
    if (argc < 3) return 1;
    HTKMiner miner(std::stoi(argv[2]));
    miner.mine(argv[1]);
    miner.saveResults("output.txt");
    return 0;
}